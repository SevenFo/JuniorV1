# 80486的指令系统

## 寻址方式

### 操作数的寻址方式

操作数的分类：存储器操作数，寄存器操作数，立即数

1. 立即寻址

   + 8/16/32 bits
   + 常数

2. 寄存器寻址

   + 注意目的和源操作数的寄存器大小需要等长

3. 存储器寻址

   地址表达式：段寄存器:[基址寄存器+变址寄存器x比例因子+位移量]

   1. 可用的寄存器

      `SI DI BP BX`都可以存储有效地址的值，并且作为基址寄存器；
      `BP`->`SS` `SI DI BX`->`DS`；
      其中`SI DI`还可以作为变址寄存器

   2. 比例因子

      在8086模式下，比例因子=1

   3. 位移量

   4. EA的总长度必须小于`0XFFFF` 16 bits，段长的限制

   5. 存储器寻址的一维、二维数组访问

      todo



### 转移地址的寻址

1. 段内的地址寻址

   + 使用符号地址表示
     + `NEAR PTR` 16 bits
     +  `SHORT`  8 bits
   + 地址存储在寄存器中，使用数据的寄存器/存储器寻址方式
     + 要注意指定地址的长度：`WORD PTR` 16 bits

2. 段间的地址寻址

   + 使用符号地址表示
     + `FAR PTR 符号地址` 
   + 地址存储在寄存器中，使用数据的寄存器/存储器寻址方式，前后两个字的分别代表IP和CS的地址
     + 要注意指定地址的长度：`DWORD PTR`  32bits

> **注意**：`FAR PTR   WORD PTR  ...`这些说明符指定的是这个地址下内容的长度，而不是地址本身的长度；地址的长度一般都是16 bits，而这个地址下的内容可能是 8 bits 也可能是 16 bits。

## 指令系统

### 数据的传输

1. 寄存器的权限说明
   + 只读寄存器：`CS 立即数`
   + 读写寄存器：`通用寄存器 SS DS ES 存储器单元`
   + 传输关系，**注意立即数不能直接写入段寄存器、CS只能由地址跳转指令进行改变不可以直接写入、只有通用寄存器才可以进行“自写入”**
     + 立即数->存储器、通用寄存器
     + 段寄存器<->通用寄存器，存储器
   
2. 指令
   + `MOV [DIS] [RES]`

     + 当两操作数的其中一个数据长度可以确定的时候，另一个操作数地长度将被自动确定

     + 当将立即数写入存储器时，需要说明目的操作数（存储器指针所指向的内容）的空间大小，否则默认向其中写入 `WORD`大小的数据

       > 如 `MOV [PTR TO RAM] 0x08`的行为和`MOV [PTR TO RAM] 0x0008`是相同的，`MOV BYTE PTR [PTR TO RAM] 0x08`才是向存储器中写入1个byte

     + 高字节对应存储器的高字节，低字节对应存储器的低字节。

   + `XCHG [DIS] [RES]`交换两个操作数的内容

     + 只能是存储器和**通用寄存器**之间进行数据交换

   + `LEA [DIS] [RES]`读取`RES`地址的**有效地址**的值，将其赋给`DIS`所指向的寄存器

     + 因为我们只能得到存储器的地址，因此`RES`肯定是存储器地址如`[PTR TO ARM]`，**不可以填写立即数或者寄存器的名字**
     + `[DIS]`是某个**可写入寄存器**的名字

     > 注意：该指令不会读取`RES`地址指向的数据的值，而是直接解析这个地址为偏移地址

   + `LDS/LES [DIS(PTR TO REGISTER)] [RES]`读取`RES`地址所指向的`DOWRD`数据，将其解析为段基址和偏移地址，偏移地址存放在`DIS`中，段基址存放在`DS/ES`段寄存器中

   + `XLAT`将`DS:[BX+AL]`地址指向的字节数据赋值给`AL`

   + `LAHF`将`FLAGS`寄存器（16 bits）的低字节部分传送到`AF`中

   + `LAHF`将`AF`寄存器（8 bits）传送到`FLAGS`寄存器中的低字节部分

     ---

   + `PUSH [RES:(PWORD/PDWORD)]` 压栈，`SP=SP-2/4`后，将`RES`地址中的数据存储到`SP`指向的内存区域中

     + 先读取数据，再移动`SP`指针

     > 表示栈指针是递减的

   + `POP [DIS:PWORD/PDWORD]` 弹栈，将`SS:[SP]`中的数据存储到`DIS`所指向的内存空间中，`SP = SP+2/4`

   + `PUSHF/POPF`将上面的命令的`DIS/RES`换成`FLAGS:PWORD`

   + `PUSHFD/POPFD个`将上面的命令的`DIS/RES`换成`FLAGS:PDWPRD`

   + `PISHA/POPA`依次将`AX CX DX BX SP BP SI DI`压/弹栈

     ---

   + `IN [AL/AX], [PORT/DX]`读取`PORT`端口的数据 或者 读取**`DX`中存储的**端口地址中的内容到所示寄存器

   + `OUT [PORT/DX], [AL/AX]`发送`PORT`/`DX`指向端口的数据到所示寄存器

   + 


### 数据的运算

#### 算术运算

+ `ADD [DIS:BYTE|WORD|DWORD] [RES:BYTE|WORD|DWORD]` 加法运算，寄存器权限同上

  **溢出的判断(`OF / AF`)**：对于有符号的数，双进位法，$C_7\bigoplus C_6=1$则`OF=1`

  对于无符号数，直接判断`CF`是否被置1

+ `ADC [DIS:BYTE|WORD|DWORD] [RES:BYTE|WORD|DWORD]`带进位的加法运算，`DIS=DIS+RES+CF`

+ `SUB [DIS:BYTE|WORD|DWORD] [RES:BYTE|WORD|DWORD]` 减法运算

+ `SBB [DIS:BYTE|WORD|DWORD] [RES:BYTE|WORD|DWORD]`带借位的减法运算，`DIS=DIS-RES-CF`

+ `INC/DEC [DIS:BYTE|WORD|DWORD]`自增、自减

  **不可以对段寄存器里的值自增或者自减**，但是可以操作`SI DI BX BP`这些存放地址的通用寄存器

+ `NEG [DIS:BYTE|WORD|DWORD]`：`DIS = 0-DIS`

  如结果为负数将自动转换为补码

+ `XADD [DIS:BYTE|WORD|DWORD] [RES:REGISTER ONLY]` : `XCHG [DIS] [RES] THEN ADD [DIS] [RES]`交换之后相加

+ `CMP [DIS] [RES]` `DIS - RES`**结果由标志位给出**

+ `COMPXCHG [DIS] [RES]` : 

  ```assembly
  CMP DIS AL/AX
  IF DIS == AL/AX 
      ZF=1 
      MOV DIS RES 
  ELSE 
      ZF=0 
      MOV AL/AX DIS
  ```

+ `MUL [RES]` : 无符号乘法，当`RES:BYTE`时`AX = AL * RES`；当`RES:WORD`时`DX:AX = AX * RES`；当`RES:DOWRD`时`EDX:EAX = EAX * RES`

+ `IMUL [RES] | [DIS] [RES] | [DIS] [RES] AMN（立即数）`：带符号乘法 三种模式可选，第一种同`MUL`指令，后面两种注意操作数等长，**并且`DIS`不可以为存储器操作数**，

+ `DIV/IDIV [RES]`：除法运算`AL|AX|EAX = AX|DX:AX|EDX|EAX / RES ... AH|DX|EDX`，**余数和商的符号相同**

  + **`RES`不可以是立即数**
  + `AL|DX:AX|EDX:EAX 必须是 RES 字长的两倍`

+ 带符号数据变长指令`CBW: AL -> AX` `CWD: AX -> DX:AX` `CWDE: AX -> EAX` `CDQ: EAX -> EDX:EAX`

  ---

+ BCD码运算调整指令

  | 运算法则 | 分离、组合 | 指令                                  |
  | -------- | ---------- | ------------------------------------- |
  | 加法     | 分离       | `AAA`                                 |
	|          | 组合       | `DAA`                                 |
  | 减法     | 分离       | `AAS`                                 |
  |          | 组合       | `DAS`                                 |
  | 乘法     |            | `AAM`实质上是将二进制转换为十进制BCD  |
  | 除法     |            | `AAD` 实质上是将十进制BCD转换为二进制 |
  
  ---

#### 逻辑运算

+ `AND OR XOR [DIS] [RES]`逻辑运算

  + **操作数不可以同时为存储器操作数，也不可以是段寄存器**

+ `NOT [DIS]`

+ `TEST [DIS] [RES]` 同`AND`但是不会将结果存储在`DIS`中

  ---

+ `SAL/SHL [DIS],[COUNT]`算术、逻辑左移；其中`COUNT`为位移的次数，8086中只能为`1`或者使用`CL`中的数指定

   + `LSB`自动补充`0`
   + `SAL`带符号 `SHL`无符号
   + `MSB`将被移动到`CF`中
   + 移动后若最高位发生变化则`OF=1`可以判断带符号数是否溢出

+ `SAR/SHR [DIS],[COUNT]`算术、逻辑右移；其中`COUNT`为位移的次数，8086中只能为`1`或者使用`CL`中的数指定
  
  + 对于`SAR`最高位保持不变，对于`SHR`最高位补`0`
  + `LSB`将被移动到`CF`中
  + 对于`SHR` 移动后若最高位和此高位不相同的时候`OF=1`
+ `ROL/ROR/RCL/RCR`循环位移
  
   + `ROL/ROR`中`CF`不在循环圈内
   + `RCL/RCR`中`CF`也参与循环

### bit 的测试

+ + G[RES]` 将`RES`指定的bit复制到`CF`中

  + `BTS/BTR/BTC`复制后本位置1/置0/取反

  + `BSF/BSR [DIS],[RES]`（bit scan foreword ）从低到高/从高到低扫描`RES`并将为`1`的位下标复制到`DIS`中

    当全为0的时候`ZF=1`否则清零

### 字符串操作

1. 默认寻址方式

   源字符串地址由`DS:SI`指定，目的字符串由`DS:DI`指定，`DF`指定字符串地址的增减，`DF=0递增；DF=1递减`，`CX`保存字符串的长度，重复操作前缀将自动更改`CX`的值

2. 指令

   + `MOVSB/MOVSW/MOVSD`分布传输`BYTE WORD DWORD`类型的字符串

     > 注意：虽然名字叫字符串传输指令，但其实每运行以此该指令只能传输字符串的一个单位，一般会搭配`REP`指令前缀一起使用

   + `LODSB LODSW LODSD`读取源字符串中的一个字节到`AL|AX|EAX`中，**并且自动修改地址指针**

   + `STOSB STOSW STOSD`将`AL|AX|EAX`中的数据存储到目的字符串中，**并且自动修改地址指针**

   + `CMPSB CMPSW CMPSD`将目的字符串和源字符串相比较，只影响标志位，**并且自动修改地址指针**

   + `SCASB SCASW SCASD`将`AX`寄存器中的内容和目的字符串的内容比较，只影响标志位，**并且自动修改地址指针**

     > 可以用来搜索某个字符

   + `INSB INSW INSD`从`DX`指定的端口读取一个单位到目的字符串中，**并且自动修改地址指针**

   + `OUTSB OUTSW OUTSD`将源字符串的一个单位传输到`DX`指定的端口，**并且自动修改地址指针**

   ---

3. 相关配合的重复性前缀

   `REP`：`DO ... ;CX--; UNTIL CX == 0`

   `REPE/REPZ` ：`DO ... ;CX--; UNTIL CX == 0 OR ZF IS 0`

   `REPNE/REPNZ` ：`DO ... ;CX--; UNTIL CX == 0 OR ZF IS 1`

### 流程控制指令

+ `JMP ADDLAB`跳转到`ADDLAB`地址标号所指向的地方
+ `JMP [PTR TO RAM/REGISTER]`将操作数直接赋值给`IP`
  + 当为段内转移的时候，`PTR 应该为 WORD`，当为短间转移的时候，`PTR 应该为 DWORD `低位`IP`高位`CS`
+ `JMP SEGEMT:OFFSET`

#### 条件转移指令

注意在80286之前，条件转移只能是短转移，在这之后，条件转移就可以是近转移了
并且条件转移指令不会影响标志位（需要自己清零）

…

todo

#### 循环控制转移指令

#### 过程调用指令



## 汇编语法

1. 标识符
   1. 标号，后面跟着冒号，表示某条指令所存放单元的符号化地址，可以作为`JMP`后面的操作数
   2. 名字，是伪指令的符号名称，不跟着冒号，**不代表地址**
2. 操作符：包括指令的助记符和伪指令的定义符
3. 操作数：
   1. 指令的操作数只能是立即数，寄存器操作数，存储器操作数
   2. 伪指令的操作数可以是常量，表达式和标号等等

---

1. 汇编中的变量：
   变量通常是值程序运行过程中可以被改变的量，其本质上是内存中的一块存储空间（即存储空间中的值在程序运运行过程中是可以被改变的）或者是寄存器中的值

   但是我们应该如何访问这个变量？

   1. 如果是寄存器中的变量，我们可以直接使用寄存器名来访问；

      > 寄存器名相当于一个固化的、常量的地址，我们无法得知这个地址的具体的值，当我们使用这个名称的时候会直接得到这个地址所代表的存储空间的值

   2. 如果是内存控制中的值，我们可以直接给出`段基础:偏移地址`这样的地址形式来访问，并且其中的`段基址``偏移地址`我们只能使用常量或者是寄存器名称来指定，这样就来了一个管理的问题：我们需要人为的将所有变量的地址值纪录下来，并且标注好这些变量的用途

   3. 为了解决上面的问题，我们可以给变量的地址取一个符号化的名称，所谓的符号化名称就是用一个字符串来代表地址的值，这样我们可以利用有意义的符号化名称来表明这个变量的用途，以减少变量管理上的负担。

   4. 变量名代表了存储器中的一个数据或数据区的符号名称，被定义在数据段，堆栈段和附加段，代表了内存操作数的存储地址

   > 注意**变量名只能被定义一次**但是可以多次访问或者引用

   变量所具有的属性：

    + 段属性，`SEG SYMBOL`可以获取`SYMBOL`的段属性
    + 偏移属性， `OFFSET SYMBOL`可以获取`SYMBOL`的偏移量
    + 类型属性，
      	+ 标号的类型属性：`FAR NEAR` 说明标号代表地址是段内还是段间
         	+ 变量的类型属性：`BYTE WORD DOWRD`

2. 汇编中的常量：**立即数**、**字符串常量**、**符号常数**

   立即数直接由数字给出加以`B Q D H`的后缀以表示数制

   字符串常量是以`“ ”`或者`‘ ’`引起来的多个字符，经过汇编后会被转换为一组`BYTE`数组

   符号化常量（类似于`#define`命令）使用`A=10 或者 A EQU 66`定义，**符号化常量在汇编的时候会被替换**，并且`EQU`定义的符号化常量不可以重复定义

3. 汇编中的运算符

   > 不可以分割寄存器，变量（即存储单元的内容）因为他是伪指令，不是汇编指令。是不可以执行的，变量的内容，寄存器只有汇编指令，才可以读写。

   1. 算术运算

      `+ - * / MOD`

   2. 位运算

   3. 关系运算（布尔运算）

      `EQ(==) NE(!=) GT(>) LT(<) GE(>=) LE(<=)`如果为真返回`0`，为假返回`0ffffH`，位数取决于操作数的位数

   4. 分离运算符
   
      `HIGH` 取高8位；`LOW` 取低8位
      
   5. **属性操作符**

         1.  `PTR`操作符 

             `BYTE|WORD|DWORD PTR ADDR_EXP`可以用来指明或临时更改地址表达式所表示空间的大小

        2. 段操作符

           其实是由`段寄存器:`这样构成的，用来说明某个地址表达式的段属性

        3. 属性读取操作符

           `SEG` 获得**变量名或者标号**的段属性

           > 为社么不能用于存储器操作数前？因为这类操作数往往由默认的段属性或者需要自己指定

           `OFFSET` 获得**变量名或者标号**的偏移属性

           `TYPE ` 获得**变量名或者标号或者常数**的类型属性

           `LENGTH` 获得`DUP`的长度
   
           `SIZE` 获得变量名或者标号所代表的数据的大小


---

   ### 结构与定义

   

汇编程序是由一个个逻辑段组成的，逻辑段是1个汇编文件的基本组成单元，逻辑段的起名没有特定的要求，但一般与段寄存器的名字相同

#### 逻辑段的构成

一个逻辑段一般以以下形式定义

```assembly
SEGMENT_NAME SEGMENT AT ADDR_OFFSET USE_TYPE 'CLASS_NAME'
	ORG ADDR_OFFSET
	...
SEGMENT_NAME END
```

| 项目                                   | 是否必须           | 说明                                                         |
| -------------------------------------- | ------------------ | ------------------------------------------------------------ |
| `SEGMENT_NAME`                         | 是                 | 作为逻辑段的段名称                                           |
| `SEGMENT`                              | 是                 | 表示在定义一个逻辑段                                         |
| `AT [ADDR_OFFSET]`                     | 否                 | 用来指定逻辑段的**段基址**，默认将被系统随即标配             |
| `USE_TYPE`                             | 否                 | 可选`USE16|SUE32`，表示16/32位的寻址方式，也就是地址的长度。<br />**若使用实地址模式，需要指定为`USE16`** |
| `CLASS_NAME`                           | 否                 | 逻辑段的分类名称                                             |
| `ORG [ADDR_OFFSET]`                    | 否                 | 表示下一个内容的偏移地址，默认为`0000H`                      |
| `ASSUME SEGMENT_REG_NAME:SEGMENT_NAME` | 代码段的第一条语句 | 用来说明各个逻辑段的起始地址将被存储在哪个段寄存器中         |

#### 数据的定义

语法：`[VAR_NAME] DB|DW|DD|DF|DQ|DT [DATA_1, DATA_2, ...]`分别为1,2,4,6,8,10字节的数据定义，其中`DATA_`可以用`?`代表没有确定的值



 
